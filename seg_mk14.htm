<!DOCTYPE html>
<html>
<head>
<style>

table {
	border-collapse: collapse;
	border: 5px solid #ddc;
	border-radius: 25px;
}

th, td{
	padding: 5px;
	text-align: top;
	background-color:#fdc;
	border: 3px solid #ddc;
	border-radius: 10px;
}

input,textarea{
	border-radius: 7px;
}

div.seg {
	padding: 5px;
	text-align: top;
	border: 3px solid #ddc;
	border-radius: 10px;
	color:#F44;
	background-color: #322;
	width:310px;
}

td:hover{
	background-color:#f5f5f5;
}

</style>
</head>
<body style="background-color: #ffffe7;">
<h2>Science of Cambridge MK14 simulator</h2>
<!--
I had one which I think is the one on Grant Searles site.
<PRE><
 <a href="http://searle.hostei.com/grant/">http://searle.hostei.com/grant/</a>
 <a href="http://searle.hostei.com/grant/my_machines/machines.html">http://searle.hostei.com/grant/my_machines/machines.html</a>
<img src="http://searle.hostei.com/grant/my_machines/mk14.jpg">
</PRE>
-->
This is an attempt to make a Science of Cambridge  MK14 simulator using JavaScipt + SVG that runs in a browser.
It is a port of Paul Robson's DOS version. It uses SVG for the LED display. It can also use ascii for the display
A timer is used to run some CPU instructions, every timer tick. <P>

References:
<a href=http://www.robsons.org.uk/archive/members.aol.com/mk14emu/ target=new1> Paul Robson's page </a> |
<a href=http://mymk14.co.uk/paulRobson/emulator.htm target=new1> copy of Paul Robson's pages </a> |
<a href=http://techlib.com/area_50/Readers/Karen/micro.htm target=new2 > Karen Orton's Page techlib.com/area_50/Readers/Karen/micro.htm</a> |
<a href=http://www.vintage-radio.net/forum/showthread.php?t=92999 target=new2 > more..</a> |
<a href=http://www.dougrice.plus.com/dev/seg_MK14.txt target=new3> MK_14 Rom listing</a> |
<a href=http://ccgi.dougrice.plus.com/cgi-bin/wiki.pl?MK14_Notes target=new4> My notes</a> |
<a href=https://github.com/doug-h-rice/virtual_mk14 > Emulator for R-Pi </a> |
<a href=http://ccgi.dougrice.plus.com/cgi-bin/wiki.pl?MK14_Scmp_Code target=new5> Scmp_Code </a> |
<a href=http://121.73.5.55/scamp/scmp.htm target=new6 > Scmp info </a> |
<a href=http://203.118.152.120/scamp/scmp.htm target=Elector > Elector Scmp info </a> |
<a href=http:seg_mk14_grid.htm target=grid > ins grid </a> |
<a href=http:seg_mk14_scmp_ins.png target=grid > ins grid </a> |
<a href=http:SCMP_dataSheet.pdf target=data > sc/mp datasheet </a> |
<a href=http://www.dougrice.plus.com target=new3> my web site</a> |
<P>
<HR>
<!-- style="color:red;background-color: #444;"-->
<pre><B><div class="seg" id="placeholder7seg" border=1 > _  _   _            _  _     _
|_||_  |  | |   _|| |_ |_||  |_||_|
| | _| |_ | |  |_||  _||  |_ | | _|

</div></B></pre>
<pre><B><div  id="placeholder7seg_" border=1 ></div></B></pre>

<div id="placeholder" border=1 ></div><div id="placeholder2" border=1 ></div>

<table border = 1>
<TR>
</TD><td>
For Tablets:<P>
<!-- the key is pressed. A timer is started for the release.<P> -->
<button onclick="tabletClick( KEY_GO )" > GO </button>
<button onclick="tabletClick( KEY_MEM )" > M </button>
<button onclick="tabletClick( KEY_ABORT )" >abt</button>
<button onclick="tabletClick( 0xA )" >  A  </button><P>
<button onclick="tabletClick( 7 )" >  7  </button>
<button onclick="tabletClick( 8 )" >  8  </button>
<button onclick="tabletClick( 9 )" >  9  </button>
<button onclick="tabletClick( 0xB )" >  B  </button><P>
<button onclick="tabletClick( 4 )" >  4  </button>
<button onclick="tabletClick( 5 )" >  5  </button>
<button onclick="tabletClick( 6 )" >  6  </button>
<button onclick="tabletClick( 0xC )" >  C  </button><P>
<button onclick="tabletClick( 1 )" >  1  </button>
<button onclick="tabletClick( 2 )" >  2  </button>
<button onclick="tabletClick( 3 )" >  3  </button>
<button onclick="tabletClick( 0xD )" >  D  </button><P>
<button onclick="tabletClick( KEY_TERM )" >  T  </button>
<button onclick="tabletClick( 0 )" >  0  </button>
<button onclick="tabletClick( 0xF )" >  F  </button>
<button onclick="tabletClick( 0xE )" >  E  </button><P>
<!--
<button onclick="tabletClick( KEY_RESET )" >  RESET </button>
-->
<button onclick="ResetCPU()" >  ResetCPU() </button><P>
timed press ---___---. <P>
</td>


<TD>
<pre>Use the left mouse to press
the buttons below:-</pre>
<table border = 1>
<tr>
<td id="myP" onmousedown="mouseDown( KEY_GO )"    onmouseup="mouseUp( KEY_GO )"     > GO </td>
<td id="myP" onmousedown="mouseDown( KEY_MEM )"   onmouseup="mouseUp( KEY_MEM )"  > MEM </td>
<td id="myP" onmousedown="mouseDown( KEY_ABORT )" onmouseup="mouseUp( KEY_ABORT )"> ABORT </td>
<td id="myP" onmousedown="mouseDown( 0xA )"       onmouseup="mouseUp( 0xA )"> A </td>
<!--
/* try and get this working  on a tablet */
<td id="myP" onmousedown="mouseDown( KEY_MEM )"  ontouchend="mouseUp( KEY_MEM )"   > MEM </td>
-->
</tr>
<tr>
<td id="myP" onmousedown="mouseDown( 7 )" onmouseup="mouseUp( 7 )"> 7 </td>
<td id="myP" onmousedown="mouseDown( 8 )" onmouseup="mouseUp( 8 )"> 8 </td>
<td id="myP" onmousedown="mouseDown( 9 )" onmouseup="mouseUp( 9 )"> 9 </td>
<td id="myP" onmousedown="mouseDown( 0xB )" onmouseup="mouseUp( 0xB )"> B </td>
</tr>
<tr>
<td id="myP" onmousedown="mouseDown( 4 )" onmouseup="mouseUp( 4 )"> 4 </td>
<td id="myP" onmousedown="mouseDown( 5 )" onmouseup="mouseUp( 5 )"> 5 </td>
<td id="myP" onmousedown="mouseDown( 6 )" onmouseup="mouseUp( 6 )"> 6 </td>
<td id="myP" onmousedown="mouseDown( 0xC )" onmouseup="mouseUp( 0xC )"> C </td>
</tr>
<tr>
<td id="myP" onmousedown="mouseDown( 1 )" onmouseup="mouseUp( 1 )"> 1 </td>
<td id="myP" onmousedown="mouseDown( 2 )" onmouseup="mouseUp( 2 )"> 2 </td>
<td id="myP" onmousedown="mouseDown( 3 )" onmouseup="mouseUp( 3 )"> 3 </td>
<td id="myP" onmousedown="mouseDown( 0xD )" onmouseup="mouseUp( 0xD )"> D </td>
</tr>
<tr>
<td id="myP" onmousedown="mouseDown( KEY_TERM )"  onmouseup="mouseUp( KEY_TERM )" > TERM </td>
<td id="myP" onmousedown="mouseDown( 0 )" onmouseup="mouseUp( 0 )"> 0 </td>
<td id="myP" onmousedown="mouseDown( 0xF )" onmouseup="mouseUp( 0xF )"> F </td>
<td id="myP" onmousedown="mouseDown( 0xE )" onmouseup="mouseUp( 0xE )"> E </td>
</tr>
<tr>
<td id="myP" onmousedown="mouseDown( KEY_RESET )" onmouseup="mouseUp( KEY_RESET )"> RESET </td>
<!--
<td id="myP" onclick="tabletClick( KEY_GO )"         > click GO </td>
-->
</tr></table>
</TD>
<TD>
<pre>
example1:
XOR and store
press
abort 0 F 2 1 Mem
C 4 Mem
A A Mem
E 4 Mem
5 5 Mem
C 8 Mem
0 2 Mem
3 F
;now to execute
abort 0 F 2 2 GO
;you should read:
0F29 FF
<!--
 0f22: ; load accumulator with 0xAA
       ; eor with 0x55 and store
 0f22: c4 aa ldi	0aah
 0f24: e4 55 xri	055h
 0f26:
 0f26: c8 02 st	2 (0)
 0f28: ; return to the monitor
 0f28: 3f    xppc	3
 0f29: ; next code is overwritten by result.
-->
 </pre>
<button onclick="pokeMem()" > setup </button>
<button onclick="tabletClick( KEY_GO )" > GO </button>
<!--
<button onclick="mouseDown( KEY_GO )" > click GO </button>
<button onclick="mouseUp( KEY_GO )" > click GO </button>
-->

</TD>
<!--
<TD>
<img src="http://searle.hostei.com/grant/my_machines/mk14.jpg">
</TD>
-->
<td>
<pre>
SCIOS saves
after 3F,
0FF9 p1h
0FFA p1l
0FFB p2h
0FFC p2l
0FFD Acc
0FFE Extension
0FFF Status
The status register:-
  7   6  5  4  3  2  1  0
cy/l,OV,SB,SA,IE,F2,F1,F0
Bit Function 	Notes
0 	F0 	Output Line
1 	F1 	Output Line
2 	F2 	Output Line
3 	IE 	Interrupt Enable
4 	SA 	Input Line + INT,
5 	SB 	Input Line
6 	OV 	Overflow
7 	CY/L Carry / Link bit

</pre>
</td>
<!--<TD>
<pre>
Example2: write to display
execute from 0F20.
Jmp to routine.
set up P1 to point to the display.

load 0xAA and write to display.

0f20: 90 00 jmp	main0
0f22:
0f22:      main0:
0f22: ; reload display pointer.
0f22: c4 00 LDI	Disp.0
0f24: 31    XPAL	1
0f25: c4 0d LDI	Disp.1
0f27: 35    XPAH	1
0f28:
0f28: c4 aa ldi	0aah
0f2a: cd 00 st	@0(1)
0f2c:
0f2c: 90 f4 jmp	main0
0f2e:
0f2e:
</pre>
<button onclick="pokeMem2()" > setup </button>
</td>
-->
</tr>
</table>
<HR>
<FORM name="F1" >

display using:
SVG: <input type=checkbox name ="svg"  checked >
ascii:<input type=checkbox name ="seg7"   >

Simulate Speed: upto
<input type=text name=ticks   size=8 value="50">CPU instructions every 150 ms
<input type=text name=tick_ms size=8 value="100">ms used. Display update:
<input type=text name=tick_display_ms size=8 value="100"> ms used.

<P>
Memory:<P>
<input type=button value="peek memory" onclick=" peekMemMessage6( ) " >
<input type=button value="poke memory" onclick=" pokeMemMessage6( ) " >
@ <input type=text name=hexlist6start value="0xF20"> to
<input type=text name=hexlist6end value="0xF40">
P0 disp
<input type=button value="calc JMP" onclick=" pokeMemMessage6jmp( ) " >
<input type=text name=hexlist6jmp value=""><P>
<P>
<input type=button value="disassemble" onclick=" peekMemMessage6dis( ) " >
<input type=button value="poke ihex" onclick="load_ihex_lines( 'hexlist6' )"><BR>

<textarea name=hexlist6  rows=7 cols=70>
</textarea><P>

<P>
Cheat:- Inject @ 0xFF9:<P>
inputs:
SIN:<input type=checkbox name ="sin" onclick="pokeSin()">
SB: <input type=checkbox name ="sb"  onclick="pokeSB()" >
SA: <input type=checkbox name ="sa"  onclick="pokeSA()" ><P>
<input type=button   value="peek @0FF9" onclick="peekMemFF9()">
<input type=button   value="poke @0FF9" onclick="pokeMemFF9()">P1h,p1l,P2h,P2l,ACC,Ext,Status,SIO
<input type=text name=hexlistFF9 size=100 value="0x00,0x00, 0x00,0x00, 0x00,0x00,0x00,1 "><P>


Cheat:- Inject code @ 0xF20:<P>
<input type=button value="poke example1 - xor and store" onclick="pokeMem1()">
<input type=text name=hexlist1 size=100 value="0x00,0x00,0xC4,0xAA,0xE4,0x55,0xC8,0x02,0x3F"><P>

Try SIO: 0xC4,0xAA,0x01,0x19,0x3f,0x19,0x3f,0x19,0x3f,0x19,0x3f,0x19,0x3f<P>

<input type=button value="poke example1a - Write to Status - and light LEDS " onclick="pokeMem1a()"    >
Try: 0x90,0x0,0xc4,0x0,0x31,0xc4,0xd,0x35,0xc4,0xaa,0xcd,0x1,0xcd,0x1,0xcd,0x1,0xcd,0x0,0x90,0xec<P>
<input type=text name=hexlist1a size=100 value="0xC4,0x77,0x07,0x3F" ><P>


<input type=button value="poke example2 - display" onclick="pokeMem2()">
<input type=text name=hexlist2 size=100 value="0x90,0x00,0xc4,0x00,0x31,0xc4,0x0D,0x35,0xc4,0xaa,0xcd,0x00,0x90,0xf4"><P>

<input type=button value="poke ihex - message.hex" onclick="load_ihex_lines( 'hexlist3' )"><BR>
<!-- <input type=text name=hexlist3 size=100 value=":180F2000C40D35C40031C40F36C47332C460C8F0C40701C280C9808F8A"><P> -->
<textarea name=hexlist3  rows=8 cols=70>
:180F2000C40D35C40031C40F36C47332C460C8F0C40701C280C9808F8A
:180F380001C4FF027094F3B8DF9CEDC6FF94E590DD8079796D4037774C
:180F500039403E3F6E406D77406E3E7F4079373071406E38383F1F4049
:130F680077406D30403940713F406D4079796D4037773946
:00000001FF
</textarea><BR>
<input type=button value="poke ihex - clock.hex" onclick="load_ihex_lines( 'hexlist4' )"><BR>
<!-- <input type=text name=hexlist4 size=100 value=":180F2000C40D35C40031C40F36C47332C460C8F0C40701C280C9808F8A"><P> -->
<textarea name=hexlist4  rows=8 cols=70>
:080F16001200000076404002C9
:180F2000C40137C40B33C40D36C40D32C40F35C41A3103C405C8DAC567
:180F3800FFEC00C900E904980498029002C900C100D40F01C380CE01B8
:180F5000C4408F00C1001C1C1C1C01C380CE02B8B09CD4C403C8AAC4DC
:180F68000001C5FFE1045801B89F9CF6019803409003C4070807C40276
:040F80008F1190A29B
:00000001FF
</textarea><P>

Duck Shoot: run from 0f23, increase nuber of instructions per timer tick as well!<P>

<input type=button value="poke Duck Shoot: run from 0f23" onclick="load_ihex_lines( 'hexlist5' )"><BR>
<textarea name=hexlist5  rows=7 cols=70>
:100f2000000000c40d35c40031c401c8f4c410c8a9
:100f3000f1c400c8eec40801c0e71ec8e49404c4ac
:100f4000619002c400c9808f01c0d89c0ec180e4aa
:100f5000ff9808c8cec0cae480c8c64003fc01940c
:090f6000d6b8bf98c8c40790ceb2
:00000001ff
</textarea><P>
<PRE>
    2 0000:             ; duck shoot
    4 0000:             ; rcasm \D puts PC relative addresses out by one.
    8 0000:
            8060{
   11 0000:             Disp:	equ 0d00H
   12 0000:             ChRom:	equ 010bH
   13 0000:             Duck:	equ 061h
   15 0000:             ;	org	0f0fh
   17 0000:             	org	0f20h
   19 0f20: 00          Row:	db 0
   20 0f21: 00          Count:	db 0
   21 0f22: 00          Sum:	db 0
   24 0f23:             Shoot:
   25 0f23:             	; reload display pointer.
   26 0f23: c4 0d       	LDI	Disp.1
   27 0f25: 35          	XPAH	1
   28 0f26: c4 00       	LDI	Disp.0
   29 0f28: 31          	XPAL	1
   30 0f29: c4 01       	LDI	1
   31 0f2b: c8 f4       	STR	Row
   32 0f2d:             React:
   33 0f2d: c4 10       	LDI 	16	; speed of flight
   34 0f2f: c8 f1       	STR	Count
   35 0f31: c4 00       	LDI	0
   36 0f33: c8 ee       	STR	Sum
   44 0f35: c4 08       Shift:	LDI	8	;Move ducks this time
   47 0f37:             	; scan each digit and key
   48 0f37: 01          Ndig:	XAE
   49 0f38:             	; row contains bit map of ducks
   50 0f38:             	; rotate and test MSB
   51 0f38:             	; to see if duck present
   52 0f38: c0 e7       	LDR	Row
   53 0f3a:             			; rotate and check if duck in msb
   54 0f3a: 1e          	RR
   55 0f3b: c8 e4       	STR	Row
   56 0f3d: 94 04       	JP	No
   58 0f3f: c4 61       	LDI	Duck
   59 0f41: 90 02       	JMP	Go
   61 0f43:             No:
   62 0f43:             	; msb no set so no duck
   63 0f43: c4 00       	LDI 	0	;No duck
   66 0f45:             Go:
   67 0f45:             	; store at display using e
   68 0f45: c9 80       	ST	-128(1)
   69 0f47:             	;DLY	01
   70 0f47: 8f 01       	DLY	01
   72 0f49: c0 d8       	LDR	Sum
   74 0f4b: 9c 0e       	JNZ	Nok	;No Key
   77 0f4d:             	; load key E contains off set
   79 0f4d: c1 80       	LD	-128(1)
   80 0f4f: e4 ff       	XRI	0FFh
   81 0f51: 98 08       	JZ	Nok	; no key pressed
   85 0f53:             	;
   86 0f53:             	;ldi	0ffh
   87 0f53: c8 ce       	STR	Sum
   88 0f55: c0 ca       	LDR	Row
   90 0f57: e4 80       	XRI	080h
   92 0f59: c8 c6       	STR	Row	;Change top bit
   93 0f5b:             Nok:
   94 0f5b: 40          	LDE
   95 0f5c: 03          	SCL
   96 0f5d: fc 01       	CAI	1	; Subtract 1
   97 0f5f: 94 d6       	JP	Ndig	;Do next digit
   99 0f61:
  100 0f61: b8 bf       	DLDR	Count
  101 0f63: 98 c8       	JZ	React	;Start new position
  103 0f65:             	;	dle 	30
  104 0f65: c4 07       	LDI	7
  105 0f67:
  106 0f67: 90 ce       	JMP	Ndig 	;Another sweep
            }
  108 0f69:
</pre>

<pre>
;
;       Converts decimal number from keyboard to hex and displays in
;       'MEM' = minus, 'TERM' clears display
;		run from 0F50h
;
:180F5000C40F36C40032C400CA12CA0CCA0EC40137C459333F9028C435
:180F68000ACA1103C212016078014078019002C21302F20CCA1340F2AC
:180F80000E01BA119CF140CA0EC213CA0C90CFE40398C3C4FFCA12905F
:010F9800C593
:00000001FF
</pre>

<pre>

;       Mastermind      (MK14 Manual)
;
;       run from 0F1Ch
;
;       Term new game
;       Mem clear
;       Go process
;
:180F1C00C400C8EDC8ED32C40F36C40137C40B33C404CA10C40F35C4E8
:180F3400143103C104EC90C904D40F01C380CD01BA109CEFC40D35C43B
:180F4C000031C103E4FF98D8C4FFCA0FC400CA00CA0102C40137C45935
:180F6400333F900B40F4F694F1C41A333F90E5E4039A1BE4059CD9C436
:180F7C000BCA00CA01C40F35C41431C48001C404CA11C1F0E5019C0C85
:180F9400AA01C1FF58C9FFC1EF58C9EFBA119CEAC404CA11C404CA1064
:180FAC00C40F37C40833C5FF940ABA119CEE9013BA1098F6C100E7FFCB
:180FC4009CF6AA00C30058CB0090E7C404CA11C100D47FCD01BA119C90
:180FDC00F6C40135C20031C100CA00C20131C100CA01C4FFCA0F925D84
:00000001FF
</pre>

<pre>
;       Moon landing (MK14 Manual)
;
;       Keys 1-7 control the thrust
;
;       Major display problems on the old emulator
;		run from 0f52
;	0f08	Alt,
;	0f0B	Vel,
;	0f0E	Acceleration,
;	0f10	Thrust,
;	0f12	Fuel
;
:180F14000850009980009998000258003EC8E3C40135C8DFC40B31C877
:180F2C00DBC0D702D40F01C180CF01C4008F04C0C91C1C1C1C010603EA
:180F440094EDC400CF01C0BB35C0B93190CEC40F35C41431C40F36C4EA
:180F5C002032C40CCAE4C10BCDFFBAE49CF8C40C37C4FF33C401CAE473
:180F7400C5069404C5049032C402CAE302C5FFE902C900BAE39CF6C19A
:180F8C00029402C499EDFFC900BAE494E3C50CAAE303C5FFF9FEC900A9
:180FA40008BAE394F50694029004C400C9FFC1FF03EC94C9FDC499ECF9
:180FBC0000C9FCC1003EC1F9940AC49903F9FA03EC009002C1FA3EC173
:180FD400F73EC7FFC5F63EC40ACAE4C7FF940AE4DF9A31BAE49CF492E3
:0A0FEC0049C109980333C90992496D
:00000001FF
</pre>

<pre>
;       Reaction Timer from the MK14 Manual
;
;       after display lights up press 'MEM'
;		run from 0f20
;
:180F2000C40D35C40031C40F36C40032C40137C45933C205018F7D029D
:180F38007094F9C90340CA0CCA0EC4A88F0003C20C68CA0CC20E68CADE
:0C0F50000E4002F90398EB3F90FD90D09A
:00000001FF
</pre>

<pre>
;       Five silver dollars - machine plays against you moving five
;       silver dollars along a track - player unable to move loses
;		run from     0F28h
;
:060F1200FF0305080900C1
:180F2800C40F36C40032C40F35C41831C406CA24C1FACD01BA249CF8EA
:180F4000C400CA25C40F35C41931C40901C408CA8040FC0194F6C4055C
:180F5800CA24C5011E940BD47F01C280DC30CA80900701C280DC06CA9E
:180F700080BA249CE5C40137C484333F902A4098F403FC0694EFC40FF3
:180F880035C418027031C10002F4FF02F9FF940290DBC2259C0340CA5C
:180FA00025609E43B9009243C2259A43C403CA24C40F35C41831C400F3
:180FB80001C10102FD02C9046001BA249CF340980EE10003FD0294F66F
:180FD00002F1F9C9F9923FC405CA24C5FF02F4FF02F9FF9406BA249C0C
:070FE800F29307B900923FEC
:00000001FF
</pre>

<pre>
;
;       multiply two unsigned 8 bit numbers
;
;       P2->0   = A
;       P2->1   = B
;       P2->2   = Result(H)
;       P2->3   = Result(L)
;       P2->-1  = Temp
;
;       .org    0F50h
:180F5000C408CAFFC400CA02CA03C201021ECA019413C202F2001FCAA3
:110F680002C2031FCA03BAFF9CE83F90DBC20290ED9D
:00000001FF
</pre>

<pre>
;       divide 16 bit by 8 bit, both unsigned
;
;
;       P2->-1                  Quotient (temp)
;       P2->0   Divisor         Quotient (high)
;       P2->1   Dividend(High)  Quotient (low)
;       P2->2   Dividend(Low)   Remainder
;	 .org    0F80h
:180F8000C20001C400CA00CAFFC2010378CA011D9404AA0090F3C20191
:180F980070CA01C2020378CA02C201FC00CA011D9404AAFF90EDC202D2
:0A0FB00070CA02C2FFCA013F90C6DA
:00000001FF
</pre>

<pre>
;       16 bit Square Root
;
;       P2 points to number on entry (Hi,Lo) -1(2) is temporary
;
Hi      = 0
Lo      = 1
Temp    = -1

        .org    0F20h

:180F2000C400CAFF03BAFFF2FF01C4FEF40001F201CA0140F200CA000D
:100F38001D940290E7C400CA00FAFFCA013F90D886
:00000001FF
</pre>

<pre>
;       moves block of memory.
;
;       From = start address
;       To = end address
;       Length = no bytes
;
#define DatPtr(x)       ((x)+1)

E       = 80h

From    = DatPtr(0F1Bh)
To      = DatPtr(0F1Dh)
Length  = DatPtr(0F1Fh)

        .org    0F20h
:180F2000C4000103C0F9F8F5C0F4F8F01D9403C0EF0102C0E87031C040
:180F3800E3F4003502C0E07032C0DBF4003602409C02C4027801C58028
:070F5000CE80B8CC9CF83FF5
:00000001FF
</pre>

test5.hex
start at 0xf20
<pre>
:100f20009006000000000000c40031c40d35c0f67a 
:100f3000c8f5c100c8f0e4ffd0ed9810c8e7e48020 
:100f40009806b8e0c8de9004a8dac8d8c0d7cd01aa 
:100f50008f0ac400cd018f0ac0cacd018f0ac40117 
:100f600036c0c1d40f32c20bcd018f0ac40b32c4bc 
:100f70000136c400cd018f0ac087cd018f0ac40598 
:100f800001c280cd018f0a909fc40201c280cd01b1 
:100f90008f0a9094c40801c280cd01c40001c280b0 
:070fa000cd0190843f90fd9c 
:00000001ff 

</pre>

</FORM>

<!--
<button onclick="">Click me</button>
-->

<h2>example 1:  XOR and store </h2>

Some very simple hex to type in to the MK 14. It works out 0xAA xor 0x55 which equals 0xFF. It stores the result in memory just after the return to the monitor.
<pre>
abort 0F22 Term

or
abort 0F21 Mem
C4 Mem
AA Mem
E4 Mem
55 Mem
C8 Mem
02 Mem
3F
;now go and execute
abort 0F22
G
;
you should read:
0F29 FF

The code assembled using rcasm or asm:
   32 0f22:
   33 0f22:             	; load accumulator with 0xAA eor with 0x55 and store
   34 0f22: c4 aa       	ldi	0aah
   35 0f24: e4 55       	xri	055h
   36 0f26:
   37 0f26: c8 02       	st	2 (0)
   38 0f28:             	; return to the monitor
   39 0f28: 3f          	xppc	3
   40 0f29:
   41 0f29:
   42 0f29:             	; next code is overwritten by result.
</pre>
<button onclick="pokeMem()" > setup </button>

<h2>example 2: write to display</h2>

execute from 0F20. Jmp to routine. set up P1 to point to the display.

load 0xAA and write to display.

<pre>
   31 0f20: 90 00       	jmp	main0
   32 0f22:
   33 0f22:             main0:
   34 0f22:             	; reload display pointer.
   35 0f22: c4 00       	LDI	Disp.0
   36 0f24: 31          	XPAL	1
   37 0f25: c4 0d       	LDI	Disp.1
   38 0f27: 35          	XPAH	1
   39 0f28:
   40 0f28: c4 aa       	ldi	0aah
   41 0f2a: cd 00       	st	@0(1)
   42 0f2c:
   43 0f2c: 90 f4       	jmp	main0
   44 0f2e:
   45 0f2e:
</pre>
<button onclick="pokeMem2()" > setup </button>

<h2>Instruction set</h2>

<P>
m is the mode bit. If 1 the instruction is auto-indexed, if 0 it is indexed.
pp refers to a pointer register, P0..P3
<P>
If mpp is 100 (you can't auto index on the program counter), this is immediate
mode. The data is in the next byte ( ). There is, of course, no store immediate.
<P>
<B>Double Byte Instructions </B>
<P>
<TABLE BORDER="3" CELLSPACING="3" CELLPADDING="2">
<TR><TD>LD/LDI</TD> <TD>11000mpp dddddddd</TD><TD>18/10</TD><TD>AC := (EA)</TD></TR>
<TR><TD>ST</TD>     <TD>11001mpp dddddddd</TD><TD>18/10</TD><TD>(EA) := ACOR</TD></TR>
<TR><TD>AND/ANI</TD><TD>11010mpp dddddddd</TD><TD>18/10</TD><TD>AC := AC &amp;&nbsp;(EA)</TD></TR>
<TR><TD>OR/ORI</TD> <TD>11011mpp dddddddd</TD><TD>18/10</TD><TD>AC := AC | (EA)</TD></TR>
<TR><TD>XOR/XRI</TD><TD>11100mpp dddddddd</TD><TD>18/10</TD><TD>AC := AC ^ (EA)</TD></TR>
<TR><TD>DAD/DAI (1)</TD><TD>11101mpp dddddddd</TD><TD>23/15</TD><TD>AC,CYL := AC+(EA)+CY/L, base 10</TD></TR>
<TR><TD>ADD/ADI</TD><TD>11110mpp dddddddd</TD><TD>19/11</TD><TD>AC,CYL := AC+(EA)+CY/L</TD></TR>
<TR><TD>CAD/CAI (2)</TD><TD>11111mpp dddddddd</TD><TD>20/12</TD><TD>AC,CYL := AC+~(EA)+CY/L</TD></TR>
<TR><TD>ILD</TD>    <TD>101010pp dddddddd</TD><TD>22</TD><TD>AC,(EA) := (EA)+1</TD></TR>
<TR> <TD>DLD</TD>   <TD>101110pp dddddddd</TD><TD>22</TD><TD>AC,(EA) := (EA)-1</TD></TR>
<TR><TD>JMP</TD>    <TD>100100pp dddddddd</TD><TD>9</TD><TD>PC := EA</TD></TR>
<TR><TD>JP</TD>     <TD>100101pp dddddddd</TD><TD>9/11</TD><TD>if AC &gt; 0&nbsp;PC := EA</TD></TR>
<TR><TD>JZ</TD>     <TD>100110pp dddddddd</TD><TD>9/11</TD><TD>if AC = 0&nbsp;PC := EA</TD></TR>
<TR><TD>JNZ</TD>    <TD>100111pp dddddddd</TD><TD>9/11</TD><TD>if AC &lt;&gt; 0 PC := EA</TD></TR>
<TR><TD>DLY</TD>    <TD>10001111 dddddddd</TD><TD>(3)</TD><TD>Delay</TD></TR>
</TABLE>
<P>
(1) DAD and DAI are decimal add instructions. These do not affect the overflow
<P>
(2) CAD and CAI are complement and add instructions, these are used to subtract.
<P>
(3) Delays for 13 + 2 * AC + 2 * dddddddd + 2^9 * dddddddd cycles. (13-131,593),
AC is set to -1 afterwards.
<P>
<B>Single Byte Instructions </B>
<P>
<TABLE BORDER="3" CELLSPACING="3" CELLPADDING="2">
<TR><TD>lde</TD> <TD>01000000</TD><TD>6</TD><TD>AC := E</TD></TR>
<TR><TD>xae</TD> <TD>00000001</TD><TD>7</TD><TD>AC &lt;-&gt; E</TD></TR>
<TR><TD>ane</TD> <TD>01010000</TD><TD>6</TD><TD>AC&nbsp;:= AC &amp; E</TD></TR>
<TR><TD>ore</TD> <TD>01011000</TD><TD>6</TD><TD>AC&nbsp;:= AC | E</TD></TR>
<TR><TD>xre</TD> <TD>01100000</TD><TD>6</TD><TD>AC&nbsp;:= AC ^ E</TD></TR>
<TR><TD>dae</TD> <TD>01101000</TD><TD>11</TD><TD>AC&nbsp;:= AC + E + CY/L base 10&nbsp;</TD></TR>
<TR><TD>ade</TD> <TD>01101000</TD><TD>7</TD><TD>AC := AC + E + CY/L</TD></TR>
<TR><TD>cae</TD> <TD>01111000</TD><TD>8</TD><TD>AC&nbsp;:= AC +&nbsp;~E + CY/L</TD></TR>
<TR><TD>xpal</TD><TD>001100pp</TD><TD>8</TD><TD>AC &lt;-&gt; P.Low</TD></TR>
<TR><TD>xpah</TD><TD>001101pp</TD><TD>8</TD><TD>AC &lt;-&gt; P.High</TD></TR>
<TR><TD>xppc</TD><TD>011111pp</TD><TD>7</TD><TD>P &lt;-&gt; P0</TD></TR>
<TR><TD>sio</TD> <TD>00011001</TD><TD>5</TD><TD>Sout := E0,E := E &gt;&gt; 1, E7 := Sin</TD></TR>
<TR><TD>sr</TD>  <TD>00011100</TD><TD>5</TD><TD>AC := AC &gt;&gt; 1</TD></TR>
<TR><TD>srl</TD> <TD>00011101</TD><TD>5</TD><TD>AC := AC &gt;&gt; 1,AC7 := CY/L</TD></TR>
<TR><TD>rr</TD>  <TD>00011110</TD><TD>5</TD><TD>rotate right AC</TD></TR>
<TR><TD>rrl</TD> <TD>00011111</TD><TD>5</TD><TD>rotate right AC,CY/L</TD></TR>
<TR><TD>halt</TD><TD>00000000</TD><TD>8</TD><TD>Pulse 'H' (doesn't stop the CPU)</TD></TR>
<TR><TD>ccl</TD> <TD>00000010</TD><TD>5</TD><TD>CY/L := 0</TD></TR>
<TR><TD>scl</TD> <TD>00000011</TD><TD>5</TD><TD>CY/L := 1</TD></TR>
<TR><TD>dint</TD><TD>00000100</TD><TD>6</TD><TD>IEN := 0</TD></TR>
<TR><TD>ien</TD> <TD>00000101</TD><TD>6</TD><TD>IEN := 1</TD></TR>
<TR><TD>csa</TD> <TD>00000110</TD><TD>5</TD><TD>AC := S</TD></TR>
<TR><TD>cas</TD> <TD>00000111</TD><TD>6</TD><TD>S := AC (not SA or SB)</TD></TR>
<TR><TD>nop</TD> <TD>00001000</TD><TD>5</TD><TD>no operation</TD></TR>
</TABLE>
<P>
<BIG>Assembler notes </BIG>
<P>
Double byte instructions are represented as follows :-
<P>
<TABLE BORDER="3" CELLSPACING="3" CELLPADDING="2">
<TR><TD>Immediate</TD><TD>ldi 4Ch</TD><TD>(immediate mode)</TD></TR>
<TR><TD>Indexed</TD><TD>ld 41(0)</TD><TD>EAC := 42 + P0</TD></TR>
<TR><TD>Auto Indexed</TD><TD>ld @4(1)</TD><TD>EAC := P1 then P1 := P1 + 4</TD></TR>
<TR><TD>Direct</TD><TD>ld 42h</TD><TD>EAC := 42 (see below)</TD></TR>
</TABLE>
<P>
There is no actual 'direct' mode. It is converted by the assembler into a
PC-relative instruction.
<P>
Because of the pre-increment fetch problem, TASM in its normal form will
assemble data references one out. So if you are going to use a data area,
do it as follows :-
<OL>
<LI>
define the DatPtr macro as #define DatPtr(a) ((a)+1)
<LI>
allocate variables by address if they are being used in direct mode MyVar
  .equ DatPtr(0FE0h)
</OL>
<P>



<h2>Requirements</h2>

My MK14 that I sold:<P>

<img src="mk14.jpg"><P>

<img src="mk14_annotated.jpg"><P>

The MK14 had ram,  rom, a National SC/MP cpu,  display,  keyboard,  glue logic, and power supply

This simulation has an array called Memory[], and the cpu is simulated.

The display and keyboard have to be emulated, so that the code the SC/MP cpu runs works.

One of the nice things was the SC/MP had "microcontroller" features with the three outputs and two inputs to the chip.

It would be nice to have cheats as well.
Poke bytes into memory.
Offset calculators.
LEDs on port pins.
Switches on SIO input.




<h2>The Display</h2>

For a good idea, see: <a href=http://techlib.com/area_50/Readers/Karen/micro.htm#PIC14 target=new2 >
Karen Orton's Page http://techlib.com/area_50/Readers/Karen/micro.htm#PIC14</a> |
 <P>

The display is at 0x0900+x where x is the digit. It is also at 0xd00+x.

The MK14 had a 4 bit latch and binary decoder 74LS154 mux.  The display lit one digit at a time.

To illumiate the LED segments, the bit pattern is written into the address, and latch.

The MK14 keeps displaying until the next write to the display. (* This simulation does not do this yet! *)

Update display() when CPU writes to the display memory.

This clobbers the speed, so only update webpage display every 150ms tick.

This program uses SVG graphics and innerHTML to render the 7-segment display.

It reads Memory[ 0x900 ] to Memory[ 0x909 ] at the moment.

<h2>The keyboard </h2>

The MK14 keyboard is scanned.

The keyboard is a 4x8 matrix sharing the display logic.
When a key is pressed a connection is made between the column and row.

When the cpu reads from the Keyboard addresses, the display decoder pulls a column low.
If a key is pressed, the accumulator has a low in the apropriate bit if the key is pressed.


In a web page you can either track key up and down.
Difficult:- Could use the mousedown() and mouseup() events.
Buttons have different events to other tags. onclick().

The JavaScipt uses onmousedown() and onmouseUp() to set and reset a bit in an array called KeyPressesdA[] indexed by the button.

This does not work on tablets, so the buttons use onclick(), which starts a timer that is clocked when the keys are scanned, and releases all keys on timeout.

This is consulted when the sc/mp reads the keyboard address.

This is 'dualport' Ram, accessed by the webpage and simulated CPU.

<PRE>
<B>Buttons:-</B>

reset

GO	MEM	Abort	A
7	8	9	B
4	5	6	C
1	2	3	D
term 	0	F	E

Layout:-
-----------------------------------
bit	|	7	6	5	4	3	2	1	0
-----------------------------------
ra3	|	7	6	5	4	3	2	1	0
ra2	|							9	8
ra1	|	Te			Ab 	Me	Go
ra0	|	F	E			D	C	B	A

http://www.javascript-coder.com/button/javascript-button-p1.phtml
</pre>

<h2>The CPU </h2>
<pre>

This ports Paul Robson's C code.

It needs the registers:
	ACC
	E
	status
	p0,p1,p2,p3

Functions:
	reset
	instructionInterpreter -  See Paul Robinson - I used his code.
	helper functions
</pre>

<h2>The Memory map </h2>
<pre>
Only the first 12 bits of the program counter are decoded

000-1FF  512 byte SCIOS ROM  Decoded by 0xxx
200-3FF  ROM Shadow / Expansion RAM
400-5FF  ROM Shadow / Expansion RAM
600-7FF  ROM Shadow / Expansion RAM
800-87F  128 bytes I/O chip RAM  Decoded by 1xx0
880-8FF  I/O Ports  Decoded by 1xx0
900-9FF  Keyboard & Display  Decoded by 1x01
A00-AFF  I/O Port & RAM Shadow
B00-BFF  256 bytes RAM (Extended) / VDU RAM  Decoded by 1011
C00-CFF  I/O Port & RAM Shadow
D00-DFF  Keyboard & Display Shadow
E00-EFF  I/O Port & RAM Shadow
F00-FFF  256 bytes RAM (Standard) / VDU RAM  Decoded by 1111
</pre>




<!-- Created with SVG-edit - http://svg-edit.googlecode.com/ -->
<!--
<svg width="64" height="100" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg" />
 <g>
  <rect height="5" width="10" y="10"   x="10"  stroke-width="2" stroke="#000000" fill="#000" id="svg_seg"  />
  <rect height="5"   width="10" y="40"   x="10"  stroke-width="2" stroke="#000000" fill="#00f" id="svg_seg"  />
  <rect height="5"   width="10" y="70"   x="10"  stroke-width="2" stroke="#000000" fill="#0f0" id="svg_seg1" />

  <rect height="30"  width="5"  y="10"   x="5"   stroke-width="2" stroke="#000000" fill="#0ff" id="svg_seg1"  />
  <rect height="30"  width="5"  y="40"   x="5"   stroke-width="2" stroke="#000000" fill="#f00" id="svg_seg1"  />

  <rect height="30"  width="5"  y="10"   x="20"  stroke-width="2" stroke="#000000" fill="#f0f" id="svg_seg1" />
  <rect height="30"  width="5"  y="40"   x="20"  stroke-width="2" stroke="#000000" fill="#ff0" id="svg_seg1" />

  <rect height="5"   width="5"  y="70"   x="25"  stroke-width="2" stroke="#000000" fill="#ffF" id="svg_seg1" />

 </g>
</SVG>
-->
<HR>

<h2>The ROM </h2>

Memory[] is populated with values from the ROM.

<a href=http://www.dougrice.plus.com/dev/seg_MK14.txt target=new3> MK_14 Rom listing</a> |
<a href=http://techlib.com/area_50/Readers/Karen/micro.htm#PIC14 target=new2 >
Karen Orton's Page http://techlib.com/area_50/Readers/Karen/micro.htm#PIC14</a> |



<h2>Conclusion </h2>

This webpage allows you to exprience the MK14.
It allows you to use a mouse to press buttons on the keypad, enter hex and run it.<P>
References to other pages provide enough information.
It also allows me to provide a sandpit for playing with machine code<P>


<pre>
/********************************************************************/
/*																	*/
/*		Portable MK14 emulator in 'C' by Paul Robson	1998		*/
/*																	*/
/*        ported to JavaScript by Doug Rice , June 2016, March2017  */
/*																	*/
/*				I built a kit in 1977 or 78								*/
/*																	*/
/*								CPU Emulator						*/
/*																	*/
/********************************************************************/
</pre>

<script>


  var F1 = window.document.forms["F1"]

  var ticks_ms=100
  var ticks=100

/********************************************************************/
/*																	*/
/*		Portable MK14 emulator in 'C' by Paul Robson	1998		*/
/*																	*/
/*        ported to JavaScript by Doug Rice , June 2016, March 2017 */
/*																	*/
/*				I built a kit in 1977 or 78								*/
/*																	*/
/*								CPU Emulator						*/
/*																	*/
/********************************************************************/

//var KEY_DIGIT	(n)					/* 0-9,A-F are 0x00-0x0F */
var	KEY_TERM	=(0x10)				/* Key codes for the other keys */
var KEY_ABORT	=(0x11)
var	KEY_GO		=(0x12)
var KEY_MEM		=(0x13)
var KEY_BREAK	=(0x14)
var KEY_RESET	=(0x15)


var Memory = new Array()
for( i = 0 ; i < 8192 ; i++){
  Memory[i*1] = 0
}

var DIGITS = 8

var LEDStat 	= new Array() //[DIGITS];
var LEDLit		= new Array() //[DIGITS];
var LatencyCount= new Array() //[DIGITS];
var KeyStatus	= new Array() //[DIGITS];

var DigitLatch 		= 0;
var SegmentLatch 	= 0;
var KeyBuffer 		= 0xFF;

LEDStat[0] = 0xFF;
LEDStat[1] = 0x55;
LEDStat[2] = 0xaa;
LEDStat[3] = 0x33;
LEDStat[4] = 0xcc;
LEDStat[5] = 0x00;
LEDStat[6] = 0xFF;
LEDStat[7] = 0xFF;

KeyStatus = ( "0xFF,0xFF,0xFF,0xFF" ).split(",")


/* http://www.techlib.com/area_50/Readers/Karen/micro.htm#PIC14 */
/*
; Page 2 - SCIOS ROM table
	ORG	H'1000'
SCIOS
*/
/* ROM from Paul's emulator */
Memory = (
"0,207,255,144,30,55,194,12,51,199,255,192,242,1,192,235,49,192,231,53,192,"+
"231,50,192,227,54,192,228,0,7,192,222,8,5,63,200,217,64,200,215,6,"+
"200,213,53,200,204,49,200,202,196,15,54,200,198,196,0,50,200,194,199,1,"+
"51,202,12,55,202,14,196,0,202,2,202,3,196,1,55,144,109,194,14,144,"+
"179,197,1,1,196,1,203,213,196,1,7,143,8,195,213,80,152,7,143,24,"+
"196,0,7,144,5,196,0,7,143,24,143,32,195,213,243,213,156,224,187,214,"+
"156,215,63,196,8,203,213,6,212,32,152,251,143,28,25,143,28,187,213,156,"+
"242,64,205,1,144,233,198,254,50,3,251,216,201,1,63,8,170,14,144,54,"+
"194,14,53,194,12,49,194,13,201,0,144,52,228,6,152,157,228,5,152,34,"+
"170,12,156,30,144,226,196,255,202,17,202,15,194,14,53,194,12,49,193,0,"+
"202,13,196,63,51,63,144,220,196,26,51,63,144,234,196,255,202,15,194,14,"+
"53,194,12,49,193,0,202,13,196,63,51,63,144,194,196,4,202,9,170,15,"+
"156,6,196,0,202,13,202,17,2,194,13,242,13,202,13,186,9,156,245,194,"+
"13,88,202,13,144,150,63,6,91,79,102,109,125,7,127,103,119,124,57,94,"+
"121,113,196,4,202,9,170,15,156,6,196,0,202,14,202,12,2,194,12,242,"+
"12,202,12,194,14,242,14,202,14,186,9,156,239,194,12,88,202,12,63,196,"+
"1,53,196,11,49,194,13,212,15,1,193,128,202,0,194,13,28,28,28,28,"+
"1,193,128,202,1,3,196,1,53,196,11,49,194,12,212,15,1,193,128,202,"+
"4,194,12,28,28,28,28,1,193,128,202,5,6,212,128,152,9,2,196,0,"+
"202,3,198,2,144,222,198,254,196,0,202,11,196,13,53,196,255,202,16,196,"+
"10,202,9,196,0,202,10,49,170,16,1,194,128,201,128,143,0,193,128,228,"+
"255,156,76,186,9,156,237,194,10,152,10,194,11,156,216,194,10,202,11,144,"+
"210,194,11,152,206,1,64,212,32,156,40,196,128,80,156,27,196,64,80,156,"+
"25,196,15,80,244,7,1,192,128,1,199,2,63,144,169,10,11,12,13,0,"+
"0,14,15,96,144,239,96,244,8,144,234,96,228,4,152,8,63,144,145,88,"+
"202,10,144,175,196,0,55,196,75,51,63,"
 ).split(",")


/*
0x0,0xcf,0xff,0x90,0x1e,0x37,0xc2,0xc,
0x33,0xc7,0xff,0xc0,0xf2,0x1,0xc0,0xeb,

0x31,0xc0,0xe7,0x35,0xc0,0xe7,0x32,0xc0,
0xe3,0x36,0xc0,0xe4,0x0,0x7,0xc0,0xde,

0x8,0x5,0x3f,0xc8,0xd9,0x40,0xc8,0xd7,
0x6,0xc8,0xd5,0x35,0xc8,0xcc,0x31,0xc8,

0xca,0xc4,0xf,0x36,0xc8,0xc6,0xc4,0x0,
0x32,0xc8,0xc2,0xc7,0x1,0x33,0xca,0xc,

0x37,0xca,0xe,0xc4,0x0,0xca,0x2,0xca,
0x3,0xc4,0x1,0x37,0x90,0x6d,0xc2,0xe,

0x90,0xb3,0xc5,0x1,0x1,0xc4,0x1,0xcb,
0xd5,0xc4,0x1,0x7,0x8f,0x8,0xc3,0xd5,

0x50,0x98,0x7,0x8f,0x18,0xc4,0x0,0x7,
0x90,0x5,0xc4,0x0,0x7,0x8f,0x18,0x8f,

0x20,0xc3,0xd5,0xf3,0xd5,0x9c,0xe0,0xbb,
0xd6,0x9c,0xd7,0x3f,0xc4,0x8,0xcb,0xd5,

0x6,0xd4,0x20,0x98,0xfb,0x8f,0x1c,0x19,
0x8f,0x1c,0xbb,0xd5,0x9c,0xf2,0x40,0xcd,

0x1,0x90,0xe9,0xc6,0xfe,0x32,0x3,0xfb,
0xd8,0xc9,0x1,0x3f,0x8,0xaa,0xe,0x90,

0x36,0xc2,0xe,0x35,0xc2,0xc,0x31,0xc2,
0xd,0xc9,0x0,0x90,0x34,0xe4,0x6,0x98,

0x9d,0xe4,0x5,0x98,0x22,0xaa,0xc,0x9c,
0x1e,0x90,0xe2,0xc4,0xff,0xca,0x11,0xca,

0xf,0xc2,0xe,0x35,0xc2,0xc,0x31,0xc1,
0x0,0xca,0xd,0xc4,0x3f,0x33,0x3f,0x90,

0xdc,0xc4,0x1a,0x33,0x3f,0x90,0xea,0xc4,
0xff,0xca,0xf,0xc2,0xe,0x35,0xc2,0xc,

0x31,0xc1,0x0,0xca,0xd,0xc4,0x3f,0x33,
0x3f,0x90,0xc2,0xc4,0x4,0xca,0x9,0xaa,

0xf,0x9c,0x6,0xc4,0x0,0xca,0xd,0xca,
0x11,0x2,0xc2,0xd,0xf2,0xd,0xca,0xd,

0xba,0x9,0x9c,0xf5,0xc2,0xd,0x58,0xca,
0xd,0x90,0x96,0x3f,0x6,0x5b,0x4f,0x66,

0x6d,0x7d,0x7,0x7f,0x67,0x77,0x7c,0x39,
0x5e,0x79,0x71,0xc4,0x4,0xca,0x9,0xaa,

0xf,0x9c,0x6,0xc4,0x0,0xca,0xe,0xca,
0xc,0x2,0xc2,0xc,0xf2,0xc,0xca,0xc,

0xc2,0xe,0xf2,0xe,0xca,0xe,0xba,0x9,
0x9c,0xef,0xc2,0xc,0x58,0xca,0xc,0x3f,

0xc4,0x1,0x35,0xc4,0xb,0x31,0xc2,0xd,
0xd4,0xf,0x1,0xc1,0x80,0xca,0x0,0xc2,

0xd,0x1c,0x1c,0x1c,0x1c,0x1,0xc1,0x80,
0xca,0x1,0x3,0xc4,0x1,0x35,0xc4,0xb,

0x31,0xc2,0xc,0xd4,0xf,0x1,0xc1,0x80,
0xca,0x4,0xc2,0xc,0x1c,0x1c,0x1c,0x1c,

0x1,0xc1,0x80,0xca,0x5,0x6,0xd4,0x80,
0x98,0x9,0x2,0xc4,0x0,0xca,0x3,0xc6,

0x2,0x90,0xde,0xc6,0xfe,0xc4,0x0,0xca,
0xb,0xc4,0xd,0x35,0xc4,0xff,0xca,0x10,

0xc4,0xa,0xca,0x9,0xc4,0x0,0xca,0xa,
0x31,0xaa,0x10,0x1,0xc2,0x80,0xc9,0x80,

0x8f,0x0,0xc1,0x80,0xe4,0xff,0x9c,0x4c,
0xba,0x9,0x9c,0xed,0xc2,0xa,0x98,0xa,

0xc2,0xb,0x9c,0xd8,0xc2,0xa,0xca,0xb,
0x90,0xd2,0xc2,0xb,0x98,0xce,0x1,0x40,

0xd4,0x20,0x9c,0x28,0xc4,0x80,0x50,0x9c,
0x1b,0xc4,0x40,0x50,0x9c,0x19,0xc4,0xf,

0x50,0xf4,0x7,0x1,0xc0,0x80,0x1,0xc7,
0x2,0x3f,0x90,0xa9,0xa,0xb,0xc,0xd,

0x0,0x0,0xe,0xf,0x60,0x90,0xef,0x60,
0xf4,0x8,0x90,0xea,0x60,0xe4,0x4,0x98,

0x8,0x3f,0x90,0x91,0x58,0xca,0xa,0x90,
0xaf,0xc4,0x0,0x37,0xc4,0x4b,0x33,0x3f,
*/

for( i = 512 ; i < 4097 ; i++){
  Memory[i] = 0
}


/********************************************************************/
/*					Helpers                        					*/
/********************************************************************/


function pokeSin( ) {
  var F1 = window.document.forms["F1"]
  if ( F1.sin.checked ) { sin = 1 } else { sin = 0 }
}

function pokeSB( ) {
  var F1 = window.document.forms["F1"]
  if ( F1.sb.checked ) { sb = 1 } else { sb = 0 }
}

function pokeSA( ) {
  var F1 = window.document.forms["F1"]
  if ( F1.sa.checked ) { sa = 1 } else { sa = 0 }
}


//onclick="alert('click!')"
function clickSin( ) {
  sin = 1-sin
}

function clickSb( ) {
  sb = 1-sb & 1
  Stat = Stat & 0xDF | ( sb << 5 )
}

function clickSa( ) {
  sa = 1-sa & 1
  Stat = Stat & 0xEF | ( sa << 4 )
}


function pokeMemFF9( ) {

//  hexA = "0xC4,0xAA,0xE4,0x55,0xC8,0x02,0x3F".split(",")
  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlistFF9.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xFF9+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}


function peekMemFF9( ) {

  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlistFF9.value.split(",")
  F1.hexlistFF9.value = ""

      F1.hexlistFF9.value += "0x"+
	   ( Memory[0xFF9] ).toString(16)+",0x"+
	   ( Memory[0xFFA] ).toString(16)+",0x"+
	   ( Memory[0xFFB] ).toString(16)+",0x"+
	   ( Memory[0xFFC] ).toString(16)+",0x"+
	   ( Memory[0xFFD] ).toString(16)+",0x"+
	   ( Memory[0xFFE] ).toString(16)+",0x"+
	   ( Memory[0xFFF] ).toString(16)+",0x"+
       ( sio ).toString(16)
}


function pokeMem( ) {
  hexA = "0xC4,0xAA,0xE4,0x55,0xC8,0x02,0x3F".split(",")
  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlist1.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xF20+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}




function pokeMem1( ) {
  //hexA = "0xC4,0xAA,0xE4,0x55,0xC8,0x02,0x3F".split(",")
  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlist1.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xF20+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}

function pokeMem1a( ) {
  //hexA = "0xC4,0xAA,0xE4,0x55,0xC8,0x02,0x3F".split(",")
  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlist1a.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xF20+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}


function pokeMem2() {
  var i
  var F1 = window.document.forms["F1"]
  hexA = F1.hexlist2.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xF20+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}

/*
:180F2000C40D35C40031C40F36C47332C460C8F0C40701C280C9808F8A
:180F380001C4FF027094F3B8DF9CEDC6FF94E590DD8079796D4037774C
:180F500039403E3F6E406D77406E3E7F4079373071406E38383F1F4049
:130F680077406D30403940713F406D4079796D4037773946
:00000001FF
*/

function pokeMem3() {
  ResetCPU()
  load_ihex_line2( ":180F2000C40D35C40031C40F36C47332C460C8F0C40701C280C9808F8A" )

  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}

function pokeMemMessage() {
  ResetCPU()

  hexStr = "0x90,0x00,0xc4,0x00,0x31,0xc4,0xod,0x35,0xc4,0xaa,0xcd,0x00,0x90,0xf4"
  var i
  var F1 = window.document.forms["F1"]

  F1.hexlist2.value.split(",")

  hexA = F1.hexlist.value.split(",")

  for( i = 0 ; i < hexA.length ; i++){
      Memory[0xF20+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}

function peekMemMessage6( ) {

  var F1    =   window.document.forms["F1"]
  var start =   F1.hexlist6start.value*1
  var end    = F1.hexlist6end.value*1
  var length = ( end - start )

  var opStr = ""

  for( i = 0 ; i < length ; i++){
    if ( ( i % 8 ) == 0 ){ opStr += "\n" }
    if ( ( i % 16 ) == 0 ){ opStr += "\n" }

    opStr += "0x" + ( Memory[ (start*1+i) ]*1 ).toString(16) +","
  }
  var F1 = window.document.forms["F1"]
  F1.hexlist6.value = opStr
}

function peekMemMessage6dis( ) {
  /* this may not be perfect, but could be good enough */
  var F1    =   window.document.forms["F1"]
  var start =   F1.hexlist6start.value*1
  var end    = F1.hexlist6end.value*1
  var memLength = ( end - start )

  var opStr = "work in progress, increment EA for jumps\n"

  var opCode = 0
  var opCodeH =0
  var opCodeL =0
  i=0;
  var op0A = ("HALT,XAE,CCL,SCL,DINT,IEN,CSA,CAS,NOP,,,,,,,"+
             ",,,,,,,,,,SIO,,,SR,SRL,RR,RRL,").split(",")

  var op30A = ("XPAL 0,XPAL 1,XPAL 2,XPAL 3,XPAH 0,XPAH 1,XPAH 2,XPAH 3,"+
           ",,,,XPCC 0,XPPC 1,XPCC 2,XPPC 3,").split(",")

  var op90A = ("JMP,JP ,JZ ,JNZ").split(",")

  var opA0A = ("ILD(0),ILD(1),ILD(2),ILD(3)").split(",")
  var opB0A = ("DLD(0),DLD(1),DLD(2),DLD(3)").split(",")

  var op7A  = (",,,,,,,,LDE,-,ANE,ORE,XRE,DAE,ADE,CAE" ).split(",")
  var opC4A = (",,,,,,,,LDI,-,ANI,ORI,XRI,DAI,ADI,CAI" ).split(",")
  var opCA  = ("0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,a,ILD,b,DLD,LD,ST ,AND,OR ,XOR,DAD,ADD,CAD" ).split(",")
  var op8aA  = (" , , , ,I, @, @, @" ).split(",")
  var op8bA  = ("(0),(1),(2),(3),(0),(1),(2),(3)" ).split(",")

/*
 c4 1100 0100  >>  100 0
 c8 1100 1000
*/
  // alert( op30A.join("="))
  while( i < memLength ){
	opCode = Memory[ (start*1+i) ]*1
	opCodeH = opCode & 0xF0
	opCodeL = opCode & 0x0F
	opCode3L = opCode & 0x07
	opCodeH2 = ( opCode >> 2 ) & 0x1F
	opCodeH3 = ( opCode & 0x07 )

    opStr += ";0x"+(start*1+i).toString(16)+": 0x" + opCode.toString(16) +","
	i++;

	if ( (opCode & 0x80 ) !=0 ){
	  var disp = Memory[ (start*1+i) ]*1
	  var dispStr = " 0x" + ( disp ).toString(16)
	  var dispStr2= " 0" + ( disp ).toString(16)+"h "

	  opStr += dispStr+","
      i++;
 	  opStr += "\n\t\t\t\t"

	  EAstr = ""
      //
	  //; ld      @-1(3)
	  //


	  if ( (opCodeL & 3) == 0 ) {
        if ( disp > 0x7F ) {
		  EA = ( -0x100+(start+i-1)*1 + disp )
        } else {
		  EA = (      0+(start+i-1)*1 + disp )
		}
        if ( EA < 0  ) {
		  EA += 0x1000
		}
        EAstr = " ;EA= 0"+EA.toString(16)+"h,0x"+EA.toString(16)
	  }

      /* delay */
	  if ( opCode  == 0x8F ) { opStr += "DLY " + dispStr2   }
	  /* jumps */
	  if ( opCodeH == 0x90 ) { opStr += op90A[ ( opCode >> 2 ) & 3 ] + dispStr2 +op8bA[  opCode3L ] + EAstr }

	  var opCodeH4 = opCA[ ( opCode & 0xF8 ) >> 3  ] + op8aA[  opCode3L ] + dispStr2 + op8bA[  opCode3L ]+ EAstr



	  if ( opCodeL == 0x4 )  { opCodeH4 = opC4A[  opCodeH2>>1 ] + dispStr2  }
	  if ( opCodeL == 0xC )  { opCodeH4 = opC4A[  opCodeH2>>1 ] + dispStr2 }

	  if ( disp == 0x80 ) { opCodeH4 +=" ; add E to ptr " }

	  if ( opCodeH == 0xA0 ) { opStr += opCodeH4 }
	  if ( opCodeH == 0xB0 ) { opStr += opCodeH4 }

	  if ( opCodeH == 0xC0 ) { opStr += opCodeH4 }
	  if ( opCodeH == 0xD0 ) { opStr += opCodeH4 }
	  if ( opCodeH == 0xE0 ) { opStr += opCodeH4 }
	  if ( opCodeH == 0xF0 ) { opStr += opCodeH4 }
	} else {
	  opStr += "\t\t"
 	  opStr += "\n\t\t\t\t"

	  if ( opCodeH == 0x00 ) { opStr += op0A[  opCode ] }
	  if ( opCodeH == 0x10 ) { opStr += op0A[  opCode ] }
	  if ( opCodeH == 0x30 ) { opStr += op30A[ opCode*1-0x30 ] }

          opCodeH5 = op7A[ ( opCode >> 3 ) & 0xF ]
	  if ( opCodeH == 0x40 ) { opStr += opCodeH5 }
	  if ( opCodeH == 0x50 ) { opStr += opCodeH5 }
	  if ( opCodeH == 0x60 ) { opStr += opCodeH5 }
	  if ( opCodeH == 0x70 ) { opStr += opCodeH5 }
	}
	opStr += "\n"
  }
  var F1 = window.document.forms["F1"]
  F1.hexlist6.value = opStr
}



function pokeMemMessage6( ) {

  var F1 = window.document.forms["F1"]
  var start  = F1.hexlist6start.value*1

  hexA = F1.hexlist6.value.split(",")
  for( i = 0 ; i < hexA.length ; i++){
      Memory[start+i] = hexA[ i ] *1
  }
  Memory[0xF0C] = 0x20
  Memory[0xF0E] = 0x0F
  tabletClick( KEY_ABORT )
}


function pokeMemMessage6jmp( ) {
  var F1    =   window.document.forms["F1"]
  var start =   F1.hexlist6start.value*1
  var end   = F1.hexlist6end.value*1
  var len   = ( end-start-1 )*1
  if ( len < 0 ) {
    len = ( 0x100 + len )*1
  }
  F1.hexlist6jmp.value = "0x"+len.toString(16)
}

/*
* convert memory at 0900 to 7 segment displays
*
* uses 8 <SVG></SVG>
*
*/

function updateDisplay7Seg(){

  var F1 = window.document.forms["F1"]
  if ( !F1.seg7.checked ) {
	 return
  }

/*
  document.getElementById("placeholder7seg").innerHTML=
" _  _  _            _  _     _    <BR>"+
"|_||_ |  | |   _|| |_ |_||  |_||_|<BR>"+
"| | _||_ | |  |_||  _||  |_ | | _|<BR>"+
"<BR>"
*/

  var  pos
  var  n
  var  segments
  var  opStr =""
  var  opStr1 =""
  var  opStr2 =""
  var  opStr3 =""
  var  opStr4 =""
  var  opStr5 =""
  for( var pos = 0 ; pos < 8 ; pos++){
    segments = LEDStat[ 7-pos ]
    n = segments
/*

0x.. notation
   01
20    02
   40
10    04
   08   80


*/
    /*
	*  I really need to do a raster, so I should do a row at a time
    *   _    line1
	*  |_|   line2
	*  |_|.  line3
	*
	*/

    if ( ( n & (0x01) ) > 0 ) { opStr1 += " _  " } else { opStr1 += "    " };
    opStr1 +=" "
    if ( ( n & (0x20) ) > 0 ) { opStr2 += "|"    } else { opStr2 += " "    };
    if ( ( n & (0x40) ) > 0 ) { opStr2 += "_"    } else { opStr2 += " "    };
    if ( ( n & (0x02) ) > 0 ) { opStr2 += "| "   } else { opStr2 += "  "   };
    opStr2 +=" "
    if ( ( n & (0x10) ) > 0 ) { opStr4 += "|"    } else { opStr4 += " "    };
    if ( ( n & (0x08) ) > 0 ) { opStr4 += "_"    } else { opStr4 += " "    };
    if ( ( n & (0x04) ) > 0 ) { opStr4 += "|"    } else { opStr4 += " "    };
    if ( ( n & (0x80) ) > 0 ) { opStr4 += "."    } else { opStr4 += " "    };
    opStr4 +=" "
    n=n+n
  }

  opStr += opStr1 +"\n";
  opStr += opStr2 +"\n";
  opStr += opStr4 +"\n\n";

    //  self.document.write("<pre>"+opStr+"</pre>");
 if (document.getElementById){
      document.getElementById("placeholder7seg").innerHTML= opStr
  }


  opStr=""

 /* status */
  var
  savedRegs = ""
  savedRegs +="0xFF9: P1: 0x"+( Memory[0xFF9]<<8|Memory[0xFFA] ).toString(16)
  savedRegs += ", P2: 0x"  +( Memory[0xFFB]<<8|Memory[0xFFC] ).toString(16)
  savedRegs += ", Acc: 0x" +( Memory[0xFFD] ).toString(16)+", E: 0x"+( Memory[0xFFE] ).toString(16)
  savedRegs += ", Status:" + ( Memory[0xFFF] ).toString(16)
  savedRegs += "\n"
  //var Stat = 0xFF

  savedRegs += " halt:" + halt +  " SIO:" + (sio&1) + " sin:" + " OP: " + ( Stat & 7 ) + sin + " SB:" + sb +  " SA:" + sa
  savedRegs += "   clickTmr: "+clickTmr

  /* work out current displayed value to work out EA */
  var addr = Memory[0xF0E]*0x100+Memory[0xF0c]*1
  var data = Memory[0xF0D]
  if ( data > 0x7f ) { data = data - 256 }

  savedRegs += "  EA: 0x" + ( (addr+data)&0xFFF ).toString(16) +"\n"


  opStr += savedRegs



  //  self.document.write("<pre>"+opStr+"</pre>");
 if (document.getElementById){
      document.getElementById("placeholder7seg_").innerHTML= opStr
  }
}



/*
*
*  Use SVG graphics to do the display
*
*/
function updateDisplay(){

 var sega,segb,segc,segd,sege,segf,segg,segdp

 var pos,segments

 var F1 = window.document.forms["F1"]

 if ( ! F1.svg.checked )  {
   document.getElementById("placeholder").innerHTML= ""
   return;
 }

 header ='<BR><svg width="490" height="150" xmlns="http://www.w3.org/2000/svg" xmlns:svg="http://www.w3.org/2000/svg"><g>\n'
 footer = '</g></svg>\n'

 seg_h  = '<rect height="5"   width="9"  stroke-width="1.5" stroke="#fff" '
 seg_v  = '<rect height="29"  width="5"  stroke-width="1.5" stroke="#fff" '
 seg_dp = '<rect height="5"   width="5"  stroke-width="1.5" stroke="#fff" '

 led_s  = '<rect height="10"   width="15"  stroke-width="1.5" stroke="#777"  '
 led_e  = ' y="100" />\n'

 text_s = '<text text-anchor="left" font-family="Sans-serif" font-size="12"  stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000" '


 on =  'fill="#f00"'
 off = 'fill="#fCfAfA"'



 opStr = ""
 opStr += header

 for( pos = 0 ; pos < 8 ; pos++){
  // segments = Memory[ 0x900 + pos ]
  segments = LEDStat[ 7-pos ]

  if  ((segments &  1  )==0 ) { sega = off} else {sega=on}
  if  ((segments &  2  )==0 ) { segb = off} else {segb=on}
  if  ((segments &  4  )==0 ) { segc = off} else {segc=on}
  if  ((segments &  8  )==0 ) { segd = off} else {segd=on}

  if  ((segments & 16  )==0 ) { sege = off}  else {sege=on}
  if  ((segments & 32  )==0 ) { segf = off}  else {segf=on}
  if  ((segments & 64  )==0 ) { segg = off}  else {segg=on}
  if  ((segments & 128 )==0 ) { segdp = off} else {segdp=on}

  opStr +=
    seg_h+sega   + 'y="10"   x="'+(10+pos*30)+'" id="svg_seg_a"/>\n'+
    seg_h+segg   + 'y="40"   x="'+(10+pos*30)+'" id="svg_seg_g"/>\n'+
    seg_h+segd   + 'y="65"   x="'+(10+pos*30)+'" id="svg_seg_d"/>\n'+
    seg_v+segf   + 'y="10"   x="'+(5 +pos*30)+'" id="svg_seg_f"/>\n'+
    seg_v+sege   + 'y="40"   x="'+(5 +pos*30)+'" id="svg_seg_e"/>\n'+
    seg_v+segb   + 'y="10"   x="'+(20+pos*30)+'" id="svg_seg_b"/>\n'+
    seg_v+segc   + 'y="40"   x="'+(20+pos*30)+'" id="svg_seg_c"/>\n'+
    seg_dp+segdp + 'y="70"   x="'+(25+pos*30)+'" id="svg_seg_dp"/>\n'
  }




  // display SIOS
  var savedRegs = "0xFF9: P1: 0x"+( Memory[0xFF9]<<8|Memory[0xFFA] ).toString(16)
  savedRegs += ", P2: 0x"  +( Memory[0xFFB]<<8|Memory[0xFFC] ).toString(16)
  savedRegs += ", Acc: 0x" +( Memory[0xFFD] ).toString(16)+", E: 0x"+( Memory[0xFFE] ).toString(16)
  savedRegs += "  clickTmr: "+clickTmr


  /* work out current displayed value to work out EA */
  var addr = Memory[0xF0E]*0x100+Memory[0xF0c]*1
  var data = Memory[0xF0D]*1
  if ( data > 0x7f ) { data = data - 256 }

  savedRegs += "  EA: 0x"+ ( (addr+data)&0xFFF ).toString(16)

  //var Stat = 0xFF
  opStr += text_s+ ' y="90" x="10" >' + savedRegs + '</text>'


  var savedRegs = "Status:" + ( Memory[0xFFF] ).toString(16)
  //var Stat = 0xFF
  opStr += text_s+ ' y="110" x="5" >' + savedRegs + '</text>'



  /* display the status */
  opStr += led_s
  if (( Stat & 0x80 ) != 0 ) { opStr += on  }
  opStr +=  ' x="60" ' + led_e

  opStr += led_s
  if (( Stat & 0x40 ) != 0 ) { opStr += on }
  opStr +=  ' x="90" ' + led_e

  opStr += led_s
  if (( Stat & 0x20 ) != 0 ) { opStr += on  }
  opStr +=  ' x="120" ' + led_e

  opStr += led_s
  if (( Stat & 0x10 ) != 0 ) { opStr += on  }
  opStr +=  ' x="150" ' + led_e


  opStr += led_s
  if (( Stat & 0x08 ) != 0 ) { opStr += on  }
  opStr +=  ' x="180" ' + led_e

  opStr += led_s
  if (( Stat & 0x04 ) != 0 ) { opStr += on  }
  opStr +=  ' x="210" ' + led_e

  opStr += led_s
  if (( Stat & 0x02 ) != 0 ) { opStr += on  }
  opStr +=  ' x="240" ' + led_e

  opStr += led_s
  if (( Stat & 0x01 ) != 0 ) { opStr += on  }
  opStr +=  ' x="270" ' + led_e


//  var savedRegs = ", Status: 0x" + ( Memory[0xFFF] ).toString(16)

  savedRegs = " <-SIO: " +(sio&1)
  //var Stat = 0xFF
  opStr += text_s+ ' y="130" x="10" >' + savedRegs + '</text>'

  led_e  = ' y="120" />\n'

  opStr += led_s
  if (( sio & 0x01 ) != 0 ) { opStr += on  }
  opStr +=  ' x="60" ' + led_e

  savedRegs = "SIN:" + (sin&1) + " ->SB: "   + ( sb&1 ) +" ->SA: "   + ( sa&1 ) +   "  halt: "   + ( halt&1 ) + " :-"
  //var Stat = 0xFF
  opStr += text_s+ ' y="130" x="80" >' + "SIN:" + (sin&1) + '</text>'

  opStr += led_s
  if (( sin & 0x01 ) != 0 ) { opStr += on  }
  opStr +=  ' x="120"   onclick="clickSin()"  '+  led_e

  opStr += text_s+ ' y="130" x="140" >' + "SB:"   + ( sb&1 ) + '</text>'
  opStr += led_s
  if ( sb   != 0 ) { opStr += on  }
  opStr +=  ' x="180"   onclick="clickSb()"  '+  led_e

  opStr += text_s+ ' y="130" x="200" >' + "SA:"   + ( sa&1 ) + '</text>'
  opStr += led_s
  if ( sa   != 0 ) { opStr += on  }
  opStr +=  ' x="240"   onclick="clickSa()"  '+  led_e

  opStr += text_s+ ' y="130" x="260" >' +  "halt:"   + ( halt&1 )  + '</text>'
  opStr += led_s
  if ( halt != 0 ) { opStr += on  }
  opStr +=  ' x="300"    '+  led_e


//  opStr += '<rect height="5" width="5" stroke-width="1.5" stroke="#f33" y="10" x="340" /> \n'


  opStr +=  footer
// <text id="svg_21" xml:space="preserve" text-anchor="middle" font-family="Sans-serif" font-size="24" y="138.5" x="183" stroke-linecap="null" stroke-linejoin="null" stroke-width="0" stroke="#000000" fill="#000000">Stop</text>

 if (document.getElementById){
      document.getElementById("placeholder").innerHTML= opStr
  }
/*
  opStr = header
  opStr += led_s + led_e
  opStr +=  footer

  if (document.getElementById){
      document.getElementById("placeholder1").innerHTML= opStr
  }
*/


}

/********************************************************************/
/*																	*/
/*						Portable MK14 emulator in 'C'				*/
/*																	*/
/*								CPU Emulator						*/
/*																	*/
/********************************************************************/

/* #include "scmp.h" */


/* This does the 12 bit ptr add. Basically there is no carry from bit   */
/* 11 into bit 12, so bits 12..15 are always unchanged					*/
/* #define ADD12(Ptr,Ofs)	((((Ptr)+(Ofs)) & 0xFFF) | ((Ptr) & 0xF000))*/
/* There are two fetches. The second is more accurate but slower... the */
/* first doesn't increment the PC correctly (12 bit fashion). In		*/
/* practice the faster one is functionally equivalent					*/
/* #define FETCH(Tgt) Tgt = Memory[(++Ptr[0]) & 0xFFF] */
/* #define FETCH(Tgt) { Ptr[0] = ADD12(Ptr[0],1);Tgt = Memory[Ptr[0]]; } */


function FETCH(Tgt) {

  Ptr[0] += 1;
  return  Memory[  Ptr[0]  ]*1

}



var Acc,Ext,Stat;					/* SC/MP CPU Registers */
var sio, sin, halt,sa,sb;

var Ptr    = new Array() //[4];
//var Memory = new Array() //[4096];	/* SC/MP Program Memory */
var Cycles;							/* Cycle Count */

  /* hardward outputs */
  sio  = 0
  halt = 0;
  /* hardware inputs */
  sin=0;
  sa =0;
  sb =0;

/* Local prototypes */
/*
static int Indexed(int);
static int AutoIndexed(int);
static int BinAdd(int,int);
static int DecAdd(int,int);
*/

/********************************************************************/
/*							Reset the CPU							*/
/********************************************************************/

function ResetCPU()
{
  Acc    = 0;
  Ext    = 0;
  Stat   = 0;					/* Zero all registers */
  Cycles = 0;
  Ptr[0] = 0;
  Ptr[1] = 0;
  Ptr[2] = 0;
  Ptr[3] = 0;

  /* reset count */
  count =0

  sin=0;
  sio=0;
  halt=0;

  /* inputs */
 /*
  sin=0;
  sa =0;
  sb =0;
 */
}

/********************************************************************/
/*					  Execute a block of code						*/
/********************************************************************/

/* #define CYCLIMIT	(10000L) */

var  CYCLIMIT	=10000

function BlockExecute()
{
  Execute(8192);							/* Do opcodes until cyclimit */

  if (CONKeyPressed(KEY_RESET))			/* Check for CPU Reset */
	ResetCPU();
}


/********************************************************************/
/*			Execute a given number of instructions					*/
/********************************************************************/
/*
#define CYC(n)	Cycles+= (long)(n)		/* Bump the cycle counter */

/* Shorthand for multiple case */

/*
#define CAS4(n) case n: case n+1: case n+2: case n+3
#define CAS3(n) case n: case n+1: case n+2
#define CM(n)	((n) ^ 0xFF) */      		/* 1's complement */

// ADD12(Ptr,Ofs)	((((Ptr)+(Ofs)) & 0xFFF) | ((Ptr) & 0xF000))

function ADD12(Ptr,Ofs){
 	return ((((Ptr)+(Ofs)) & 0xFFF) | ((Ptr) & 0xF000))
}

var Cycles_inc

function  CYC( n ){	
    Cycles_inc = n
	Cycles += (n*1)	
	count = count - n
	}	/* Bump the cycle counter */

										/* Shorthand for multiple case */
/*
function  CAS4(n) { case n: case n+1: case n+2: case n+3 }
function  CAS3(n) { case n: case n+1: case n+2 }
*/
function  CM(n)	  { return( (n) ^ 0xFF)  }    		/* 1's complement */

function Execute( Count)
{
/*
register int Opcode;
register int Pointer;
int n;
long l;
*/

var Opcode;
var Opcode1;
var Pointer;
var n;
var l;

while ( Count > 0 )	{
	Count += -1;	/* */
	while (Cycles > CYCLIMIT)			/* Check for cycle limit */
	{
	    Latency();
		Cycles = Cycles - CYCLIMIT;
		// CONSynchronise(CYCLIMIT);
	}
	
//	FETCH(Opcode);		/* Fetch the opcode, hack of the */
    Ptr[0] += 1;
    Opcode  = Memory[  Ptr[0]  ]*1
    Opcode1 = Memory[  Ptr[0] + 1 ]*1

	Pointer = Opcode & 3;				/* pointer reference */

	switch(Opcode)						/* Pointer instructions first */
		{
										/* LD (Load) */
//		CAS4(0xC0):
		case 0xC0:
		case 0xC1:
		case 0xC2:
		case 0xC3:

			Acc = ReadMemory(Indexed(Pointer));CYC(18);break;
		case 0xC4:	Acc= FETCH(Acc);CYC(10);break;

//		CAS3(0xC5):
		case 0xC5:
		case 0xC6:
		case 0xC7:

   		  Acc = ReadMemory(AutoIndexed(Pointer));CYC(18);break;
		case 0x40:	Acc = Ext;CYC(6);break;

										/* ST (Store) */
//		CAS4(0xC8):
		case 0xC8:
		case 0xC9:
		case 0xCA:
		case 0xCB:

		    WriteMemory(Indexed(Pointer),Acc);CYC(18);break;
//		CAS3(0xCD):
		case 0xCD:
		case 0xCE:
		case 0xCF:

		    WriteMemory(AutoIndexed(Pointer),Acc);CYC(18);break;

										/* AND (And) */
//		CAS4(0xD0):
		case 0xD0:
		case 0xD1:
		case 0xD2:
		case 0xD3:

		    Acc = Acc & ReadMemory(Indexed(Pointer));CYC(18);break;
		case 0xD4:

		    n=FETCH(n);Acc = Acc & n;CYC(10);break;
//		CAS3(0xD5):
		case 0xD5:
		case 0xD6:
		case 0xD7:

		    Acc = Acc & ReadMemory(AutoIndexed(Pointer));CYC(18);break;
		case 0x50:
		    Acc = Acc & Ext;CYC(6);break;

										/* OR (Or) */
//		CAS4(0xD8):
		case 0xD8:
		case 0xD9:
		case 0xDA:
		case 0xDB:

		    Acc = Acc | ReadMemory(Indexed(Pointer));CYC(18);break;
		case 0xDC:
		    n=FETCH(n);Acc = Acc | n;CYC(10);break;
//		CAS3(0xDD):
		case 0xDD:
		case 0xDE:
		case 0xDF:

		    Acc = Acc | ReadMemory(AutoIndexed(Pointer));CYC(18);break;
		case 0x58:
		    Acc = Acc | Ext;CYC(6);break;

										/* XOR (Xor) */
//		CAS4(0xE0):
		case 0xE0:
		case 0xE1:
		case 0xE2:
		case 0xE3:

		    Acc = Acc ^ ReadMemory(Indexed(Pointer));CYC(18);break;
		case 0xE4:
		    n=FETCH(n);Acc = Acc ^ n;CYC(10);break;
//		CAS3(0xE5):
		case 0xE5:
		case 0xE6:
		case 0xE7:

		    Acc = Acc ^ ReadMemory(AutoIndexed(Pointer));CYC(18);break;
		case 0x60:
		    Acc = Acc ^ Ext;CYC(6);break;

										/* DAD (Dec Add) */
//		CAS4(0xE8):
		case 0xE8:
		case 0xE9:
		case 0xEA:
		case 0xEB:

		    Acc = DecAdd(Acc,ReadMemory(Indexed(Pointer)));CYC(23);break;
		case 0xEC:
		    n=FETCH(n);Acc = DecAdd(Acc,n);CYC(15);break;
//		CAS3(0xED):
		case 0xED:
		case 0xEE:
		case 0xEF:
		    Acc = DecAdd(Acc,ReadMemory(AutoIndexed(Pointer)));CYC(23);break;
		case 0x68:
		    Acc = DecAdd(Acc,Ext);CYC(11);break;

										/* ADD (Add) */
//		CAS4(0xF0):
		case 0xF0:
		case 0xF1:
		case 0xF2:
		case 0xF3:
		    Acc = BinAdd(Acc,ReadMemory(Indexed(Pointer)));CYC(19);break;
		case 0xF4:
		    n=FETCH(n);CYC(11);Acc = BinAdd(Acc,n);break;
//		CAS3(0xF5):
		case 0xF5:
		case 0xF6:
		case 0xF7:
			CYC(19);Acc = BinAdd(Acc,ReadMemory(AutoIndexed(Pointer)));break;
		case 0x70:
		    Acc = BinAdd(Acc,Ext);CYC(7);break;

										/* CAD (Comp Add) */
//		CAS4(0xF8):
		case 0xF8:
		case 0xF9:
		case 0xFA:
		case 0xFB:

		    Acc = BinAdd(Acc,CM(ReadMemory(Indexed(Pointer))));CYC(20);break;
		case 0xFC:
		    n=FETCH(n);CYC(12);Acc = BinAdd(Acc,CM(n));break;
//		CAS3(0xFD):
		case 0xFD:
		case 0xFE:
		case 0xFF:

		    Acc = BinAdd(Acc,CM(ReadMemory(AutoIndexed(Pointer))));CYC(20);break;
		case 0x78:
		    Acc = BinAdd(Acc,CM(Ext));CYC(8);break;

//		CAS4(0x30):		/* XPAL */
		case 0x30:
		case 0x31:
		case 0x32:
		case 0x33:

			n = Ptr[Pointer];CYC(8);
			Ptr[Pointer] = (n & 0xFF00) | Acc;
			Acc = n & 0xFF;
			break;
//		CAS4(0x34):		/* XPAH */
		case 0x34:
		case 0x35:
		case 0x36:
		case 0x37:
			n = Ptr[Pointer];CYC(8);
			Ptr[Pointer] = (n & 0xFF) | (Acc << 8);
			Acc = (n >> 8) & 0xFF;
			break;
//		CAS4(0x3C):						/* XPPC */
		case 0x3C:
		case 0x3D:
		case 0x3E:
		case 0x3F:

 		    n = Ptr[Pointer];Ptr[Pointer] = Ptr[0];Ptr[0] = n;
			CYC(7);break;

//		CAS4(0x90):							/* Jumps */
		case 0x90:
		case 0x91:
		case 0x92:
		case 0x93:
			CYC(11);Ptr[0] = Indexed(Pointer);break;
//		CAS4(0x94):
		case 0x94:
		case 0x95:
		case 0x96:
		case 0x97:
			CYC(11);n = Indexed(Pointer);
			if ((Acc & 0x80) == 0) Ptr[0] = n;
			break;
//		CAS4(0x98):
		case 0x98:
		case 0x99:
		case 0x9A:
		case 0x9B:
			CYC(11);n = Indexed(Pointer);if (Acc == 0) Ptr[0] = n;
			break;
//		CAS4(0x9C):
		case 0x9C:
		case 0x9D:
		case 0x9E:
		case 0x9F:
			CYC(11);n = Indexed(Pointer);if (Acc != 0) Ptr[0] = n;
			break;
//		CAS4(0xA8):		/* ILD and DLD */
		case 0xA8:
		case 0xA9:
		case 0xAA:
		case 0xAB:
			n = Indexed(Pointer);Acc = (ReadMemory(n)+1) & 0xFF;
			CYC(22);
			WriteMemory(n,Acc);
			break;
//		CAS4(0xB8):
		case 0xB8:
		case 0xB9:
		case 0xBA:
		case 0xBB:
			n = Indexed(Pointer);Acc = (ReadMemory(n)-1) & 0xFF;
			CYC(22);
			WriteMemory(n,Acc);
			break;

		case 0x8F:							/* DLY */
			n=FETCH(n);dlyl = (n) & 0xFF;
			dlyl = (514 * dlyl + 13 + Acc*1); Acc = 0xFF;
			CYC(dlyl);
			break;

		case 0x01:							/* XAE */
			n = Acc;Acc = Ext;Ext = n;
			CYC(5);
			break;
		case 0x19:							/* SIO */
			sio = Ext&1;
			CYC(5);
			Ext = (Ext >> 1) & 0x7F ;
			Ext = Ext |  ( sin << 7 ) ;
			break;

		case 0x1C:							/* SR */
			CYC(5);
			Acc = (Acc >> 1) & 0x7F;
			break;
		case 0x1D:							/* SRL */
			Acc = (Acc >> 1) & 0x7F;
			CYC(5);
			Acc = Acc | (Stat & 0x80);
			break;
		case 0x1E:							/* RR */
			n = Acc;Acc = (Acc >> 1) & 0x7F;
			if (n & 0x1) Acc = Acc | 0x80;
			CYC(5);
			break;
		case 0x1F:							/* RRL */
			n = Acc;Acc = (Acc >> 1) & 0x7F;
			if (Stat & 0x80) Acc = Acc | 0x80;
			//Stat = Stat & 0x7F ;
		    Stat = (Stat & 0x4F) | ( sb+sb+sa ) << 4 ;
			if (n & 0x1) Stat = Stat | 0x80;
			CYC(5);
			break;

		case 0x00:							/* HALT */
			halt = 1;
 		    CYC(8);
			break;

		case 0x02:							/* CCL */
			// Stat &= 0x7F;CYC(5);break;
			Stat = ( Stat & 0x4F ) | ( sb+sb+sa ) << 4 ;
			CYC(5);
			break;
		case 0x03:							/* SCL */
			Stat |= 0x80;
			CYC(5);
			break;
		case 0x04:                    		/* DINT */
			Stat &= 0xF7;
			CYC(6);
			break;
		case 0x05:							/* IEN */
			Stat |= 0x08;
			CYC(6);
			break;
		case 0x06:							/* CSA */
			Acc  = ( Stat & 0xCF ) | ( sb+sb+sa ) << 4 ;
			CYC(5);
			break;
		case 0x07:                   		/* CAS */
			Stat = ( Acc  & 0xCF ) | ( sb+sb+sa ) << 4 ;
			CYC(6);
			break;
		case 0x08:							/* NOP */
			CYC(6);
			break;
		default:
			CYC(6);
			break;		
		}
	}
}

/********************************************************************/
/*							  Decimal Add							*/
/********************************************************************/

function DecAdd( v1,v2)
{
  var n1 = (v1 & 0xF) + (v2 & 0xF);			/* Add LSB */
  var n2 = (v1 & 0xF0) + (v2 & 0xF0);			/* Add MSB */
  if (Stat & 0x80) n1++;						/* Add Carry */
    Stat = Stat & 0x7F;							/* Clear CYL */
  if (n1 > 0x09)								/* Digit 1 carry ? */
	{
	n1 = n1 - 0x0A;
	n2 = n2 + 0x10;
	}
  n1 = (n1 + n2);
  if (n1 > 0x99)								/* Digit 2 carry ? */
	{
	n1 = n1 - 0xA0;
	Stat = Stat | 0x80;
	}
  return(n1 & 0xFF);
}

/********************************************************************/
/*							  Binary Add							*/
/********************************************************************/
/*
#define SGN(x) ((x) & 0x80)
*/
function SGN(x) { return ((x) & 0x80) }


function  BinAdd( v1, v2)
{
  var n;
  n = v1 + v2 + ((Stat & 0x80) ? 1 : 0);	/* Add v1,v2 and carry */
  Stat = Stat & 0x3F;						/* Clear CYL and OV */
  if (n & 0x100) Stat = Stat | 0x80;		/* Set CYL if required */
  if (SGN(v1) == SGN(v2) &&				/* Set OV if required */
			SGN(v1) != SGN(n)) Stat |= 0x40;
  return(n & 0xFF);
}

/********************************************************************/
/*							Indexing Mode							*/
/********************************************************************/

function Indexed( p )
{
  var Offset
  Offset = FETCH(Offset);  /* Get offset */


  if (Offset == 0x80) Offset = Ext;		/* Using 'E' register ? */
  if (Offset & 0x80) Offset = Offset-256;	/* Sign extend */
  return(ADD12(Ptr[p],Offset));			/* Return result */
}

/********************************************************************/
/*						  Auto-indexing mode						*/
/********************************************************************/

function AutoIndexed( p)
{
  var Offset,Address;
  Offset=FETCH(Offset);

							/* Get offset */
  if (Offset == 0x80) Offset = Ext;		/* Using E ? */
  if (Offset  & 0x80) Offset = Offset-256;	/* Sign extend */
  if (Offset  < 0)							/* Pre decrement on -ve offset */
	Ptr[p] = ADD12(Ptr[p],Offset);
  Address = Ptr[p];						/* The address we're using */
  if (Offset > 0)							/* Post increment on +ve offset */
	Ptr[p] = ADD12(Ptr[p],Offset);
  return(Address);
}


/********************************************************************/
/*						Read a memory location						*/
/********************************************************************/

function ReadMemory( Address)
{
  //var opStr1 = ""
  //opStr1 =  "RD:" + Address.toString(16)  +  "<BR>"
  //document.write( opStr1 )


  var n = Address & 0x0F00;
  if (n == 0x900 || n == 0xD00)			/* Handle I/O at 900 or D00 */
	{
	n = Address & 0x0F;					/* Digit select latch value */
	SetDigitLatch(n,0);					/* Digit select latch changed */
	return(n < 8 ? KeyStatus[n]:0xFF);	/* 0..7 are keys,8..F return FF */
	}
  else									/* Just return memory contents */
	return(Memory[Address & 0xFFF]);
}

/********************************************************************/
/*						Write a memory location						*/
/********************************************************************/

function  WriteMemory( Address, Data)
{
  //var opStr1 = ""
  //opStr1 =  "WR:" + Address.toString(16) + " " + Data.toString(16) +  "<BR>"
  //document.write( opStr1 )


  var  n = Address & 0x0F00;				/* Find out which page */
  if (n == 0x900 || n == 0xD00)			/* Writing to I/O */
	{
	SegmentLatch = Data;				/* Update segment latch */
	n = Address & 0xF;
	SetDigitLatch(n,1);					/* and digit latch */
	}
  else                                    /* Writing to memory - check it */
	{									/* isn't ROM */
	if (n >= 0x200)						/* Changed for expansion RAM */
			Memory[Address & 0xFFF] = Data;
	}
}


/********************************************************************/
/*						Update the digit latch						*/
/********************************************************************/

/*

var DIGITS 		= 8

var LEDStat 	= new Array() //[DIGITS];
var LEDLit		= new Array() //[DIGITS];
var LatencyCount= new Array() //[DIGITS];
var KeyStatus	= new Array() //[DIGITS];

var DigitLatch 		= 0;
var SegmentLatch 	= 0;
var KeyBuffer 		= 0xFF;

*/


function SetDigitLatch( n, Write)
{


  /* run a time slice for the key press */


  //opStr1 =  "disp:" + n.toString(16) + " " + Write.toString(16) +  "<BR>"
    //document.write( opStr1 )


  if (n < DIGITS && Write != 0)			/* Only 0..8 are LED digits */
	{
	  if (LEDStat[n] != SegmentLatch)		/* Update display if changed */
		{
		LEDLit[n] = LEDLit[n] | SegmentLatch;
		//CONDrawLED(DIGITS-1-n,LEDLit[n]);
		LEDStat[n] = SegmentLatch;
		}
	  LatencyCount[n] = 15;				/* Refresh latency anyway */
	} else {
      tabletClickTimeoutTs( )		/* reading keys so clock keyPressedTimeout for button onClick */
	}
    DigitLatch = n;							/* Update the latch */
	Count = 0
    //updateDisplay()
}

/********************************************************************/
/*					Latency Check / Keyboard Scan					*/
/********************************************************************/

var debug

function Latency()
{
  var n,k;
  for (n = 0;n < DIGITS;n++)				/* For each LED except latched one */
	{
	if (LEDLit[n] != LEDStat[n])
		{
		LEDLit[n] = LEDStat[n];
		//CONDrawLED(DIGITS-1-n,LEDLit[n]);
		}
	if (n != DigitLatch &&				/* Check the latency thing on the */
				LatencyCount[n] > 0)	/* LED Displays */
		{
		LatencyCount[n]--;				/* Decrement it, when zero blank it */
		if (LatencyCount[n] == 0)
			{
			//CONDrawLED(DIGITS-1-n,0);
			 /* disable latency to stop flicker */
			//LEDStat[n] = 0;
			}
		}
	switch(n)							/* Work out what keys are pressed */
		{
		case 0: k = Keyboard(0x00,0x08,0xFF,0x0A);		break;
		case 1: k = Keyboard(0x01,0x09,0xFF,0x0B);		break;
		case 2: k = Keyboard(0x02,0xFF,KEY_GO,0x0C);	break;
		case 3: k = Keyboard(0x03,0xFF,KEY_MEM,0x0D);	break;
		case 4: k = Keyboard(0x04,0xFF,KEY_ABORT,0xFF);	break;
		case 5: k = Keyboard(0x05,0xFF,0xFF,0xFF);		break;
		case 6: k = Keyboard(0x06,0xFF,0xFF,0x0E);		break;
		case 7: k = Keyboard(0x07,0xFF,KEY_TERM,0x0F);	break;

		default:k = 0xFF;break;
		}

        debug = k
	    KeyStatus[n] = k;					/* Update the keystatus array */
	}

	//Count = 0
    //updateDisplay()

}


/********************************************************************/
/*					  Get a keyboard bit pattern					*/
/********************************************************************/
var KeyPressesdA = new Array()
var clickTmr = 0


function initKeyboard(){

KeyPressesdA[ KEY_GO ] =0
KeyPressesdA[ KEY_MEM ] =0
KeyPressesdA[ KEY_ABORT ] =0
KeyPressesdA[ KEY_TERM ] =0
KeyPressesdA[ KEY_RESET ] =0
KeyPressesdA[ 0xFF ] =0

KeyPressesdA[ 0 ] =0
KeyPressesdA[ 1 ] =0
KeyPressesdA[ 2 ] =0
KeyPressesdA[ 3 ] =0
KeyPressesdA[ 4 ] =0
KeyPressesdA[ 5 ] =0
KeyPressesdA[ 6 ] =0
KeyPressesdA[ 7 ] =0
KeyPressesdA[ 8 ] =0
KeyPressesdA[ 9 ] =0
KeyPressesdA[ 0xA ] =0
KeyPressesdA[ 0xB ] =0
KeyPressesdA[ 0xC ] =0
KeyPressesdA[ 0xD ] =0
KeyPressesdA[ 0xE ] =0
KeyPressesdA[ 0xF ] =0


LEDStat[0]=0
LEDStat[1]=0
LEDStat[2]=0
LEDStat[3]=0
LEDStat[4]=0
LEDStat[5]=0
LEDStat[6]=0
LEDStat[7]=0
LEDStat[8]=0

}

function CONKeyPressed( c ){
  return KeyPressesdA[ c ]*1
}

function  Keyboard( c1, c2, c3, c4)
{
  var KeyBuffer = 0xFF;

  if (c1 != 0xFF) if (CONKeyPressed(c1)) KeyBuffer &= 0x7F;
  if (c2 != 0xFF) if (CONKeyPressed(c2)) KeyBuffer &= 0xBF;
  if (c3 != 0xFF) if (CONKeyPressed(c3)) KeyBuffer &= 0xDF;
  if (c4 != 0xFF) if (CONKeyPressed(c4)) KeyBuffer &= 0xEF;
  //alert( KeyBuffer )

  return(KeyBuffer*1);
}


/********************************************************************/
/*					JavaScript functions to track button pressed	*/
/********************************************************************/

/*
* MK14 does not like two buttons pressed at once!
*/

function mouseUp( key ){
  KeyPressesdA[ key ] = 0
  pressed = 0
}

function mouseDown( key ){
  /* MK14 does not like two buttons pressed at once! */
  initKeyboard()
  KeyPressesdA[ key ] = 1
  pressed = 1
}

function tabletClick( key ){
  KeyPressesdA[ key ] = 1
  pressed = 1
  /* start timer , clocked when key read */
  clickTmr = 16 /* 2 scans */
}


function tabletClickTimeoutTs(  ){
  /* onClick needs a timer to release the key, decrement when keyboard read SetDigitLatch() */
  if ( clickTmr > 0 ){
    clickTmr +=-1
	if ( clickTmr==0 ){
      for( var i in KeyPressesdA ){
        KeyPressesdA[ i ] = 0
      }
      pressed = 0
    }
  }
}


function processButton(){
  pressed = 1-pressed
}

/********************************************************************/
/*					JavaScript Time Slice          					*/
/********************************************************************/

/*********************************************************************


run time slice,

only run cpu or display if the timer tick has not taken very long.

If the last time tick has taken more than 150ms do not run this time.

*********************************************************************/

var dT
var d_display_T
var updatingDisplay

updatingDisplay = ( 0==1 )


function timeslice(){

  var t_start = new Date()

  var F1 = window.document.forms["F1"]

  var instructions = F1.ticks.value*1

  if ( instructions > 2500 ){ /* limit */
    F1.ticks.value = 2500
  }
  if ( count > 0 ){
  } else {
    /* JavaScript needs some idle time to Paint the display */
    /* run some instructions - if SetDigitLatch( n, Write) called this may be truncated */
    Execute( instructions )
  }

  /* work out how long simulated SC/MP cput ran for */
  var t_end = new Date()

  dT  = ( t_end.getTime() - t_start.getTime() )
  F1.tick_ms.value = dT


  var t_start = new Date()

  if ( ! updatingDisplay ) {
	updatingDisplay = ( 0==0 )
    updateDisplay()
	updateDisplay7Seg()
	updatingDisplay = ( 0==1 )
  }
  /* work out how long simulated SC/MP cput ran for */
  var t_end = new Date()
  d_display_T  = ( t_end.getTime() - t_start.getTime() )

  F1.tick_display_ms.value = d_display_T

  if (CONKeyPressed(KEY_RESET)){			/* Check for CPU Reset */
	ResetCPU();
  }

//  updateDisplay()
//	updateDisplay7Seg()

}


/********************************************************************/
/*					IHEX functions 						      		*/
/********************************************************************/

/* load one line */

function load_ihex_line2( str ) {

    // alert( str )
    // Expect lines like this:
    // :10010000214601360121470136007EFE09D2190140
    // : 10 0100 00       21 46 01 36 01 21 47 01 36 00 7E FE 09 D2 19 01     40
    // That is (without spaces)
    // CC AAAAA TT DD DD DD .. DD KK
    // CC is the byte count (# of DD pairs)
    // AA is the 16-bit address (offset) from base
    // TT is the type
    // KK checksum (twos compliment of sum of all bytes)


	/* load memory */

	var i,CC,AAAAA,tt,kk,length,addr,data

	if ( str.substr(0,1) == ":" ){
	  CC    = str.substr(1,2)
	  AAAAA = str.substr(3,4)
	  tt    = str.substr(7,2)
	  length = ("0x"+CC)*1
	  addr   = ("0x"+AAAAA )*1

	  for( i = 0 ; i < length ; i++ ){
	    data   = ("0x"+str.substr(9+i*2,2) )*1
	    Memory[ (addr+i) ] = data
      }
	  kk = (str.substr(9+i*2,2) )
	}
	//alert( CC+","+AAAAA+","+"kk:"+kk )
}


function load_ihex_lines( textarea ) {
  var F1A = window.document.forms["F1"]
  /* split hex file on : to find lines starting with : */
  hexA = F1A[ textarea ].value.split(":")
  for( i = 0 ; i < hexA.length ; i++){
    load_ihex_line2( (":" + hexA[ i ]) )
  }
}

/********************************************************************/
/*					Main                        					*/
/********************************************************************/

initKeyboard()
//updateDisplay()
ResetCPU()
count =0

window.setInterval("timeslice( )", 150 ); /* run a time slice every tick, the pause allows the browser to RePaint the display */

//window.setInterval("updateDisplay()", 500 ); /* run a time slice every tick, the pause allows the browser to RePaint the display */
//updateDisplay()
</script>
</pre>
</body>
</html>
